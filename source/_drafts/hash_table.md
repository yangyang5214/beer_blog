### hash table

- 计算位置：确定关键词存储位置（根据散列函数）
- 解决冲突：解决多个关键词位置相同的问题

时间复杂度都是O(1),即查找时间与问题的规模无关。


**装填因子**

a=n/m , n 为关键字个数，m 为表长

一般取 [0.5,0.85]

a 越大，填满的元素越多，空间利用率高了，但是，冲突的机会加大了。反之亦然。



#### 构造方法

- 计算简单
- 地址空间分布均匀，尽量减少冲突

##### 数字
**直接定址法**
取关键字的某个线性函数值为散列地址

**除留余数法**

**数字分析法**
手机号，身份证号等

**折叠法**
把关键字分割成位数相同的一个部分，然后叠加

**平方取中法**


##### 字符

**ASCII码加码**

**前三个字符移位法**

**移位法**

#### 冲突处理方法

- 开放地址法

如果有冲突，就按照某种规则去寻找另一空地址

线性探测：出现聚集现象

平方探测：增量序列是平方函数。但是可能出现找不到空位的情况。（如果是4k+3）的形式不存在找不到空位。

双散列探测：Double Hashing

再散列：Rehashing 当散列元素太多，查找效率会下降。散列表扩大时，原有元素需要重新计算。


- 链地址法

将相同位置上冲突的所有关键字存储在同一个单链表中

### 散列表性能分析

平均查找长度（ASL）

**影响因素**

- 散列函数是否均匀
- 处理冲突的办法
- 散列表的填充因子（a）


1. 选择合适的key，散列法的查找效率期望是O(1),几乎与关键字的空间的大小n无关!

2. 他是以较小的a为前提。因此，散列方法是一个以空间换时间

3. 散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合范围查找，或最大值最小值查找


### 应用

文件中单词词频统计








